import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, onSnapshot } from 'firebase/firestore';

// Helper function to convert base64 to ArrayBuffer (for potential future audio needs, though not used here)
const base64ToArrayBuffer = (base64) => {
  const binaryString = window.atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
};

// Helper function to convert PCM to WAV (for potential future audio needs, though not used here)
const pcmToWav = (pcmData, sampleRate) => {
  const numChannels = 1; // Mono audio
  const bytesPerSample = 2; // 16-bit PCM

  const dataLength = pcmData.length * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataLength);
  const view = new DataView(buffer);

  let offset = 0;

  function writeString(str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset + i, str.charCodeAt(i));
    }
    offset += str.length;
  }

  function writeUint32(val) {
    view.setUint32(offset, val, true);
    offset += 4;
  }

  function writeUint16(val) {
    view.setUint16(offset, val, true);
    offset += 2;
  }

  // RIFF chunk descriptor
  writeString('RIFF');
  writeUint32(36 + dataLength); // file size - 8
  writeString('WAVE');

  // FMT sub-chunk
  writeString('fmt ');
  writeUint32(16); // sub-chunk size
  writeUint16(1); // audio format (1 = PCM)
  writeUint16(numChannels);
  writeUint32(sampleRate);
  writeUint32(sampleRate * numChannels * bytesPerSample); // byte rate
  writeUint16(numChannels * bytesPerSample); // block align
  writeUint16(bytesPerSample * 8); // bits per sample

  // DATA sub-chunk
  writeString('data');
  writeUint32(dataLength);

  // Write PCM data
  for (let i = 0; i < pcmData.length; i++) {
    view.setInt16(offset, pcmData[i], true);
    offset += bytesPerSample;
  }

  return new Blob([view], { type: 'audio/wav' });
};


const PlayerInput = ({ id, name, onNameChange }) => (
  <div className="flex items-center space-x-2 w-full md:w-1/2 lg:w-1/3 p-2">
    <label htmlFor={`player-${id}-name`} className="text-gray-700 font-medium w-24">
      Player {id}:
    </label>
    <input
      id={`player-${id}-name`}
      type="text"
      value={name}
      onChange={(e) => onNameChange(id - 1, e.target.value)}
      placeholder={`Player ${id} Name`}
      className="flex-grow p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm"
    />
  </div>
);

const ScoreInput = ({ id, name, score, onScoreChange }) => (
  <div className="flex items-center space-x-2 w-full md:w-1/2 lg:w-1/3 p-2">
    <label htmlFor={`player-${id}-score`} className="text-gray-700 w-24">
      {name || `Player ${id}`}:
    </label>
    <input
      id={`player-${id}-score`}
      type="number"
      value={score === null ? '' : score}
      onChange={(e) => onScoreChange(id - 1, parseInt(e.target.value) || 0)}
      placeholder="Score"
      className="flex-grow p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm"
    />
  </div>
);

const App = () => {
  const [firebaseApp, setFirebaseApp] = useState(null);
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [errorMessage, setErrorMessage] = useState('');
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [players, setPlayers] = useState(Array(6).fill('').map((_, i) => ({ id: i + 1, name: `Player ${i + 1}` })));
  const [currentRoundScores, setCurrentRoundScores] = useState(Array(6).fill(0));
  const [gameHistory, setGameHistory] = useState([]); // Stores [{ round: 1, date: "YYYY-MM-DD", scores: [s1, s2, ...] }, ...]
  const [totalScores, setTotalScores] = useState(Array(6).fill(0));
  const [currentDate, setCurrentDate] = useState(new Date().toISOString().split('T')[0]); // YYYY-MM-DD

  // New states for Gemini API integration
  const [roundSummary, setRoundSummary] = useState('');
  const [gameStatistics, setGameStatistics] = useState(''); // New state for game statistics
  const [apiLoading, setApiLoading] = useState(false);
  const [apiError, setApiError] = useState('');
  const [allGameData, setAllGameData] = useState([]); // To store history of all past games

  // Initialize Firebase and set up auth listener
  useEffect(() => {
    try {
      const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
      const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

      if (!Object.keys(firebaseConfig).length) {
        throw new Error("Firebase config is missing. Cannot initialize Firebase.");
      }

      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const authInstance = getAuth(app);

      setFirebaseApp(app);
      setDb(firestore);
      setAuth(authInstance);

      const unsubscribe = onAuthStateChanged(authInstance, async (user) => {
        if (user) {
          setUserId(user.uid);
          console.log("Firebase authenticated with user ID:", user.uid);
        } else {
          // Sign in anonymously if no user is present
          console.log("No user found, signing in anonymously...");
          try {
            await signInAnonymously(authInstance);
            setUserId(authInstance.currentUser?.uid || crypto.randomUUID());
            console.log("Signed in anonymously with user ID:", authInstance.currentUser?.uid);
          } catch (anonError) {
            console.error("Anonymous sign-in failed:", anonError);
            setErrorMessage("Failed to sign in to Firebase. Some features may not work.");
            setUserId(crypto.randomUUID()); // Fallback to a random ID
          }
        }
        setLoading(false);
      });

      return () => unsubscribe();
    } catch (error) {
      console.error("Firebase initialization failed:", error);
      setErrorMessage("Failed to initialize Firebase. Please check the configuration.");
      setLoading(false);
      setUserId(crypto.randomUUID()); // Ensure userId is set even if Firebase fails
    }
  }, []);

  // Use __initial_auth_token if available
  useEffect(() => {
    const signInWithToken = async () => {
      if (auth && typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
        try {
          await signInWithCustomToken(auth, __initial_auth_token);
          console.log("Signed in with custom token.");
        } catch (error) {
          console.error("Custom token sign-in failed:", error);
          setErrorMessage("Failed to sign in with custom token. Falling back to anonymous.");
        }
      }
    };
    if (auth) {
      signInWithToken();
    }
  }, [auth]);

  // Load current game data and all game history from Firestore
  useEffect(() => {
    if (db && userId) {
      const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
      const gameDocRef = doc(db, `artifacts/${appId}/users/${userId}/rummikub_games`, 'default_game');
      const allGamesDocRef = doc(db, `artifacts/${appId}/users/${userId}/rummikub_all_game_history`, 'summary');


      const unsubscribeGame = onSnapshot(gameDocRef, (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          console.log("Current Game data loaded:", data);
          setPlayers(data.players || Array(6).fill('').map((_, i) => ({ id: i + 1, name: `Player ${i + 1}` })));
          setGameHistory(data.gameHistory || []);
          setTotalScores(data.totalScores || Array(6).fill(0));
          setCurrentDate(data.currentDate || new Date().toISOString().split('T')[0]);
          setCurrentRoundScores(Array(6).fill(0));
        } else {
          console.log("No current game data found, starting fresh.");
          saveGame({
            players,
            gameHistory: [],
            totalScores: Array(6).fill(0),
            currentDate: new Date().toISOString().split('T')[0]
          });
        }
        setLoading(false);
      }, (error) => {
        console.error("Error fetching current game data:", error);
        setErrorMessage("Failed to load current game data. Please refresh.");
        setLoading(false);
      });

      // Load all game history
      const unsubscribeAllGames = onSnapshot(allGamesDocRef, (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          setAllGameData(data.allGames || []);
          console.log("All game history loaded:", data.allGames);
        } else {
          console.log("No all game history found, initializing empty.");
          setAllGameData([]);
          // No need to save an empty doc immediately, it will be created on first game finish
        }
      }, (error) => {
        console.error("Error fetching all game history:", error);
      });

      return () => {
        unsubscribeGame();
        unsubscribeAllGames();
      };
    }
  }, [db, userId]);

  // Function to save current game data to Firestore
  const saveGame = async (gameData) => {
    if (!db || !userId) {
      console.error("Firestore or User ID not available for saving current game.");
      setErrorMessage("Cannot save current game: Firebase not ready.");
      return;
    }
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const gameDocRef = doc(db, `artifacts/${appId}/users/${userId}/rummikub_games`, 'default_game');
    try {
      await setDoc(gameDocRef, gameData, { merge: true });
      console.log("Current game data saved successfully.");
    } catch (e) {
      console.error("Error saving current game document: ", e);
      setErrorMessage("Failed to save current game data.");
    }
  };

  // Function to save all game history to Firestore
  const saveAllGameHistory = async (newAllGameData) => {
    if (!db || !userId) {
      console.error("Firestore or User ID not available for saving all game history.");
      setErrorMessage("Cannot save all game history: Firebase not ready.");
      return;
    }
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const allGamesDocRef = doc(db, `artifacts/${appId}/users/${userId}/rummikub_all_game_history`, 'summary');
    try {
      await setDoc(allGamesDocRef, { allGames: newAllGameData }, { merge: true });
      console.log("All game history saved successfully.");
    } catch (e) {
      console.error("Error saving all game history document: ", e);
      setErrorMessage("Failed to save all game history.");
    }
  };


  const handlePlayerNameChange = (index, newName) => {
    const updatedPlayers = players.map((p, i) => (i === index ? { ...p, name: newName } : p));
    setPlayers(updatedPlayers);
    saveGame({ players: updatedPlayers });
  };

  const handleCurrentRoundScoreChange = (index, score) => {
    const updatedScores = [...currentRoundScores];
    updatedScores[index] = score;
    setCurrentRoundScores(updatedScores);
  };

  const handleDateChange = (e) => {
    setCurrentDate(e.target.value);
    saveGame({ currentDate: e.target.value });
  };

  const addRoundScores = () => {
    // Check if any player has not entered a score
    if (currentRoundScores.some(score => typeof score !== 'number' || isNaN(score))) {
      setErrorMessage("Please enter a valid score for all players.");
      return;
    }
    setErrorMessage(''); // Clear previous errors
    setGameStatistics(''); // Clear statistics when a new round is added

    const newGameHistory = [
      ...gameHistory,
      { round: gameHistory.length + 1, date: currentDate, scores: [...currentRoundScores] }
    ];

    const newTotalScores = totalScores.map((total, i) => total + currentRoundScores[i]);

    setGameHistory(newGameHistory);
    setTotalScores(newTotalScores);
    setCurrentRoundScores(Array(6).fill(0)); // Reset for next round
    setRoundSummary(''); // Clear previous summary

    saveGame({ gameHistory: newGameHistory, totalScores: newTotalScores, currentDate: currentDate });
  };

  const confirmResetGame = () => {
    setShowConfirmation(true);
  };

  const resetGame = async () => {
    setShowConfirmation(false);

    // Save current game as a completed game to allGameData before resetting
    if (gameHistory.length > 0) {
      const gameSummary = {
        date: currentDate,
        players: players.map(p => p.name),
        finalScores: totalScores,
        roundsPlayed: gameHistory.length
      };
      const newAllGameData = [...allGameData, gameSummary];
      await saveAllGameHistory(newAllGameData);
      setAllGameData(newAllGameData); // Update local state immediately
    }

    setPlayers(Array(6).fill('').map((_, i) => ({ id: i + 1, name: `Player ${i + 1}` })));
    setGameHistory([]);
    setCurrentRoundScores(Array(6).fill(0));
    setTotalScores(Array(6).fill(0));
    setCurrentDate(new Date().toISOString().split('T')[0]); // Reset date to today
    setErrorMessage(''); // Clear any errors
    setRoundSummary(''); // Clear LLM output
    setGameStatistics(''); // Clear LLM output
    setApiError(''); // Clear LLM error

    // Save an empty current game state to clear it in Firestore
    await saveGame({
      players: Array(6).fill('').map((_, i) => ({ id: i + 1, name: `Player ${i + 1}` })),
      gameHistory: [],
      totalScores: Array(6).fill(0),
      currentDate: new Date().toISOString().split('T')[0]
    });
  };

  // Function to call Gemini API
  const callGeminiApi = async (prompt) => {
    setApiLoading(true);
    setApiError('');
    let retries = 0;
    const maxRetries = 5;
    const baseDelay = 1000; // 1 second

    while (retries < maxRetries) {
      try {
        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = ""; // Canvas will automatically provide it in runtime
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          throw new Error(`API error: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
          return result.candidates[0].content.parts[0].text;
        } else {
          throw new Error("Unexpected API response structure or no content.");
        }
      } catch (error) {
        console.error(`Gemini API call failed (attempt ${retries + 1}):`, error);
        retries++;
        if (retries < maxRetries) {
          const delay = baseDelay * Math.pow(2, retries - 1); // Exponential backoff
          await new Promise(res => setTimeout(res, delay));
        } else {
          throw error; // Re-throw if max retries reached
        }
      }
    }
  };

  const generateLastRoundSummary = async () => {
    if (gameHistory.length === 0) {
      setApiError("No rounds have been played yet to summarize!");
      setApiLoading(false);
      return;
    }

    try {
      const lastRound = gameHistory[gameHistory.length - 1];
      const playerScores = lastRound.scores.map((score, index) => {
        const playerName = players[index]?.name || `Player ${index + 1}`;
        return `${playerName}: ${score}`;
      }).join(', ');

      const prompt = `Summarize the last round of Rummikub based on these scores: ${playerScores}. Make it a short, fun, and lighthearted commentary, highlighting any standout performances or surprising outcomes.`;
      const summary = await callGeminiApi(prompt);
      setRoundSummary(summary);
      setGameStatistics(''); // Clear statistics when generating summary
    } catch (error) {
      setApiError("Failed to generate round summary. Please try again.");
    } finally {
      setApiLoading(false);
    }
  };

  const generateStatistics = async () => {
    if (allGameData.length === 0 && gameHistory.length === 0) {
      setApiError("No game data available to generate statistics. Play some rounds or games first!");
      setApiLoading(false);
      return;
    }

    try {
      // Combine current game history with all past games for comprehensive stats
      let allPlayerScoresAcrossAllGames = {};
      let allPlayerNames = new Set(players.map(p => p.name).filter(name => name.trim() !== ''));

      // Process all past games
      allGameData.forEach(game => {
        game.players.forEach((playerName, index) => {
          allPlayerNames.add(playerName);
          if (!allPlayerScoresAcrossAllGames[playerName]) {
            allPlayerScoresAcrossAllGames[playerName] = { total: 0, rounds: 0, highestRoundScore: 0 };
          }
          // Assuming finalScores in allGameData entry represents total for that game
          allPlayerScoresAcrossAllGames[playerName].total += game.finalScores[index];
          allPlayerScoresAcrossAllGames[playerName].rounds += game.roundsPlayed;
          // Note: Cannot easily get individual round scores from 'finalScores', this might need adjustment if detailed round stats are needed
        });
      });

      // Process current game (if not empty)
      if (gameHistory.length > 0) {
        players.forEach((player, pIndex) => {
          allPlayerNames.add(player.name);
          if (!allPlayerScoresAcrossAllGames[player.name]) {
            allPlayerScoresAcrossAllGames[player.name] = { total: 0, rounds: 0, highestRoundScore: 0 };
          }
          allPlayerScoresAcrossAllGames[player.name].total += totalScores[pIndex];
          allPlayerScoresAcrossAllGames[player.name].rounds += gameHistory.length; // Add current game's rounds
        });

        // Also find highest single round score from current game
        gameHistory.forEach(round => {
          round.scores.forEach((score, pIndex) => {
            const playerName = players[pIndex]?.name || `Player ${pIndex + 1}`;
            if (allPlayerScoresAcrossAllGames[playerName]) {
              if (score > allPlayerScoresAcrossAllGames[playerName].highestRoundScore) {
                allPlayerScoresAcrossAllGames[playerName].highestRoundScore = score;
              }
            }
          });
        });
      }


      let statsString = `Overall Rummikub Statistics across ${allGameData.length + (gameHistory.length > 0 ? 1 : 0)} game(s):\n\n`;
      let playerStats = [];
      Object.keys(allPlayerScoresAcrossAllGames).forEach(playerName => {
        const stats = allPlayerScoresAcrossAllGames[playerName];
        if (stats.rounds > 0) {
            playerStats.push(`${playerName}: Total Score = ${stats.total}, Average Score per Round = ${((stats.total / stats.rounds)).toFixed(2)}, Highest Single Round Score = ${stats.highestRoundScore}`);
        }
      });
      statsString += playerStats.join('\n');

      const prompt = `Based on the following Rummikub game statistics, provide a concise and engaging summary, highlighting overall performance and any interesting trends or standouts: \n\n${statsString}\n\nKeep it under 150 words.`;

      const statsSummary = await callGeminiApi(prompt);
      setGameStatistics(statsSummary);
      setRoundSummary(''); // Clear round summary when generating statistics
    } catch (error) {
      setApiError("Failed to generate game statistics. Please try again.");
    } finally {
      setApiLoading(false);
    }
  };


  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-100 font-inter">
        <div className="text-xl text-gray-700">Loading Rummikub Game...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 p-4 sm:p-6 font-inter text-gray-800 flex flex-col items-center">
      <div className="bg-white rounded-xl shadow-lg p-6 sm:p-8 w-full max-w-4xl border border-gray-200">
        <h1 className="text-4xl font-extrabold text-center text-blue-700 mb-6 tracking-tight">
          Rummikub Score Tracker üÉè
        </h1>

        {errorMessage && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-md mb-4 flex items-center justify-between shadow-sm" role="alert">
            <span>{errorMessage}</span>
            <button
              onClick={() => setErrorMessage('')}
              className="ml-4 text-red-700 hover:text-red-900 focus:outline-none"
              aria-label="Close error message"
            >
              &times;
            </button>
          </div>
        )}

        {userId && (
          <div className="text-center text-sm text-gray-600 mb-4 bg-gray-50 p-2 rounded-md border border-gray-100">
            Your User ID: <span className="font-mono text-gray-800 break-all">{userId}</span>
          </div>
        )}

        {/* Date Input */}
        <section className="mb-8 p-4 bg-yellow-50 rounded-lg shadow-inner border border-yellow-200">
          <h2 className="text-2xl font-bold text-yellow-600 mb-4 text-center">Game Date</h2>
          <div className="flex justify-center items-center">
            <label htmlFor="game-date" className="sr-only">Game Date</label>
            <input
              id="game-date"
              type="date"
              value={currentDate}
              onChange={handleDateChange}
              className="p-3 border border-gray-300 rounded-md focus:ring-yellow-500 focus:border-yellow-500 shadow-sm text-lg w-full max-w-xs"
            />
          </div>
        </section>

        {/* Player Names Section */}
        <section className="mb-8 p-4 bg-blue-50 rounded-lg shadow-inner border border-blue-200">
          <h2 className="text-2xl font-bold text-blue-600 mb-4 text-center">Players</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {players.map((player) => (
              <PlayerInput
                key={player.id}
                id={player.id}
                name={player.name}
                onNameChange={handlePlayerNameChange}
              />
            ))}
          </div>
        </section>

        {/* Current Round Scores Section */}
        <section className="mb-8 p-4 bg-green-50 rounded-lg shadow-inner border border-green-200">
          <h2 className="text-2xl font-bold text-green-600 mb-4 text-center">Current Round Scores</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            {players.map((player, index) => (
              <ScoreInput
                key={player.id}
                id={player.id}
                name={player.name}
                score={currentRoundScores[index]}
                onScoreChange={handleCurrentRoundScoreChange}
              />
            ))}
          </div>
          <div className="flex justify-center">
            <button
              onClick={addRoundScores}
              className="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 transform hover:scale-105"
            >
              Add Round Scores
            </button>
          </div>
        </section>

        {/* Gemini API Features Section */}
        <section className="mb-8 p-4 bg-indigo-50 rounded-lg shadow-inner border border-indigo-200">
          <h2 className="text-2xl font-bold text-indigo-600 mb-4 text-center">AI Game Insights ‚ú®</h2>
          <div className="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mb-6">
            <button
              onClick={generateLastRoundSummary}
              disabled={apiLoading || gameHistory.length === 0}
              className="px-6 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 transition duration-200 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {apiLoading ? 'Summarizing...' : 'Summarize Last Round ‚ú®'}
            </button>
            <button
              onClick={generateStatistics}
              disabled={apiLoading}
              className="px-6 py-3 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 transition duration-200 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {apiLoading ? 'Generating Stats...' : 'View Game Statistics üìä'}
            </button>
          </div>

          {(roundSummary || gameStatistics || apiError) && (
            <div className="mt-6 p-4 bg-white rounded-md border border-gray-200 shadow-sm text-gray-700">
              {apiLoading && <p className="text-center text-indigo-500">Loading AI insights...</p>}
              {apiError && <p className="text-red-600 font-medium text-center">{apiError}</p>}
              {roundSummary && (
                <div>
                  <h3 className="text-xl font-semibold text-teal-700 mb-2">Round Summary:</h3>
                  <p>{roundSummary}</p>
                </div>
              )}
              {gameStatistics && (
                <div className={roundSummary ? "mt-4 pt-4 border-t border-gray-200" : ""}>
                  <h3 className="text-xl font-semibold text-purple-700 mb-2">Game Statistics:</h3>
                  <p>{gameStatistics}</p>
                </div>
              )}
            </div>
          )}
        </section>

        {/* Scoreboard Section */}
        <section className="mb-8 p-4 bg-purple-50 rounded-lg shadow-inner border border-purple-200">
          <h2 className="text-2xl font-bold text-purple-600 mb-4 text-center">Scoreboard</h2>
          <div className="overflow-x-auto">
            <table className="min-w-full bg-white border border-gray-200 rounded-lg shadow-sm">
              <thead>
                <tr className="bg-purple-100 text-purple-800 border-b border-purple-300">
                  <th className="py-3 px-4 text-left font-semibold text-sm sm:text-base">Round</th>
                  <th className="py-3 px-4 text-left font-semibold text-sm sm:text-base">Date</th>
                  {players.map((player) => (
                    <th key={player.id} className="py-3 px-4 text-left font-semibold text-sm sm:text-base">
                      {player.name}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {gameHistory.length > 0 ? (
                  <>
                    {gameHistory.map((roundData, index) => (
                      <tr key={roundData.round} className={`border-b border-gray-200 ${index % 2 === 0 ? 'bg-white' : 'bg-gray-50'}`}>
                        <td className="py-3 px-4 text-sm sm:text-base">{roundData.round}</td>
                        <td className="py-3 px-4 text-sm sm:text-base">{roundData.date}</td>
                        {players.map((_, scoreIndex) => (
                          <td key={scoreIndex} className="py-3 px-4 text-sm sm:text-base">{roundData.scores[scoreIndex]}</td>
                        ))}
                      </tr>
                    ))}
                    <tr className="bg-purple-200 text-purple-900 font-bold border-t-2 border-purple-400">
                      <td className="py-3 px-4 text-lg">Total</td>
                      <td className="py-3 px-4 text-lg"></td> {/* Empty cell for date column in total row */}
                      {totalScores.map((total, index) => (
                        <td key={index} className="py-3 px-4 text-lg">{total}</td>
                      ))}
                    </tr>
                  </>
                ) : (
                  <tr>
                    <td colSpan={players.length + 2} className="py-4 text-center text-gray-500">
                      No rounds played yet. Add scores above!
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </section>

        {/* Game Actions */}
        <section className="flex justify-center mt-8">
          <button
            onClick={confirmResetGame}
            className="px-6 py-3 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 transform hover:scale-105"
          >
            Reset Game
          </button>
        </section>

        {/* Confirmation Modal */}
        {showConfirmation && (
          <div className="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-xl shadow-2xl p-6 md:p-8 border border-gray-300 w-full max-w-sm text-center">
              <h3 className="text-xl font-bold text-gray-800 mb-4">Confirm Reset</h3>
              <p className="text-gray-700 mb-6">
                Are you sure you want to reset the game? This action cannot be undone.
              </p>
              <div className="flex justify-center space-x-4">
                <button
                  onClick={resetGame}
                  className="px-5 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-200"
                >
                  Yes, Reset
                </button>
                <button
                  onClick={() => setShowConfirmation(false)}
                  className="px-5 py-2 bg-gray-300 text-gray-800 font-semibold rounded-lg shadow-md hover:bg-gray-400 transition duration-200"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default App;
